import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Count the number of lines in a file
 * @param {string} filePath - The path to the file
 * @returns {number} - The number of lines in the file
 */
function countLines(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n').length;
    return lines;
  } catch (err) {
    return 0;
  }
}

// Directories to exclude from the tree
const EXCLUDED_DIRS = new Set([
  'node_modules',
  '.git',
  '.vscode',
  'dist',
  'build',
  'coverage'
]);

/**
 * Recursively builds a tree structure of the directory
 * @param {string} dirPath - The directory path to scan
 * @param {string} prefix - The prefix for tree formatting
 * @param {boolean} isLast - Whether this is the last item in the current level
 * @param {string} relativePath - The relative path from root for context
 * @returns {string} - The formatted tree structure
 */
function buildTree(dirPath, prefix = '', isLast = true, relativePath = '') {
  let output = '';
  const dirName = path.basename(dirPath);
  
  // Skip excluded directories
  if (EXCLUDED_DIRS.has(dirName)) {
    return '';
  }

  // Check if it's a directory or file
  let stats;
  try {
    stats = fs.statSync(dirPath);
  } catch (err) {
    return ''; // Skip if we can't read it
  }

  // Add current directory/file to output
  const connector = isLast ? '└── ' : '├── ';
  const displayName = relativePath === '' ? path.basename(dirPath) : dirName;
  
  // For files, add line count
  if (!stats.isDirectory()) {
    const lineCount = countLines(dirPath);
    output += prefix + connector + displayName + ` (${lineCount} lines)\n`;
    return output;
  }
  
  // For directories, just show the name
  output += prefix + connector + displayName + '\n';

  // Read directory contents
  let items;
  try {
    items = fs.readdirSync(dirPath);
  } catch (err) {
    return output; // Skip if we can't read the directory
  }

  // Filter out excluded directories
  items = items.filter(item => !EXCLUDED_DIRS.has(item));

  // Sort: directories first, then files, both alphabetically
  items.sort((a, b) => {
    const aPath = path.join(dirPath, a);
    const bPath = path.join(dirPath, b);
    const aIsDir = fs.statSync(aPath).isDirectory();
    const bIsDir = fs.statSync(bPath).isDirectory();

    if (aIsDir && !bIsDir) return -1;
    if (!aIsDir && bIsDir) return 1;
    return a.localeCompare(b);
  });

  // Process each item
  items.forEach((item, index) => {
    const itemPath = path.join(dirPath, item);
    const isLastItem = index === items.length - 1;
    const extension = isLast ? '    ' : '│   ';
    const newPrefix = prefix + extension;

    output += buildTree(itemPath, newPrefix, isLastItem, item);
  });

  return output;
}

/**
 * Find the project root directory
 * @returns {string} - The project root directory path
 */
function findProjectRoot() {
  // Start from the script's directory
  let currentDir = __dirname;
  
  // Go up one level from scripts directory to get project root
  const projectRoot = path.resolve(currentDir, '..');
  
  // Verify that package.json exists in the root
  const packageJsonPath = path.join(projectRoot, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    return projectRoot;
  }
  
  // If not found, use current working directory as fallback
  return process.cwd();
}

/**
 * Main function to generate the project structure
 */
function generateProjectStructure() {
  const rootDir = findProjectRoot();
  console.log('Scanning project structure...');
  console.log('Root directory:', rootDir);

  // Build the tree
  const tree = buildTree(rootDir, '', true, '');

  // Create the markdown content
  const timestamp = new Date().toLocaleString();
  const markdownContent = `# Project Structure

> Generated on: ${timestamp}

This document provides a complete overview of the project structure, showing all directories and files while excluding build artifacts and dependencies.

## Directory Tree

\`\`\`
${tree.trim()}
\`\`\`

## Notes

- **Excluded directories**: \`node_modules\`, \`.git\`, \`.vscode\`, \`dist\`, \`build\`, \`coverage\`
- This structure shows the complete \`src\` folder hierarchy
- Root-level configuration files are included for reference

## Key Directories

- **src/**: Main source code directory
- **docs/**: Documentation files
- **scripts/**: Utility scripts (including this generator)

---

*This file was automatically generated by \`scripts/generate-structure.js\`*
`;

  // Write to PROJECT_STRUCTURE.md
  const outputPath = path.join(rootDir, 'PROJECT_STRUCTURE.md');
  fs.writeFileSync(outputPath, markdownContent, 'utf8');

  console.log('✓ Project structure generated successfully!');
  console.log('✓ Output file:', outputPath);
  console.log('\nYou can now view PROJECT_STRUCTURE.md in the root directory.');
}

// Run the script
try {
  generateProjectStructure();
} catch (error) {
  console.error('Error generating project structure:', error);
  process.exit(1);
}

